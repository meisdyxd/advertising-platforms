# Рекламные площадки
Локально можно все поднять через docker-compose up -d

http://localhost:8080/swagger/index.html - сваггер(сам сваггер обворачивает символы при запросе, поэтому для более хорошего экспириенса рекомендуется кидать запросы с постмана)

Эндпоинты

- GET http://localhost:8080/api/platforms/{*location}
- POST http://localhost:8080/api/platforms/

http://localhost:5341/ - seq (admin:secure)

Покрыл юнит тестами, использовал кэширование, использовал LRU кэш, чтобы не хранить огромное количество локаций.
Структура для хранения платформ была выбрана древовидная, хотя как будто можно было что-то и получше выбрать.

Пытался следовать чистой архитектуре. Внедрил IOptions паттерн, CQRS + MediatR. Написал Pipeline Behavior для валидации commands/query.
Использовал Fluent Validation для валидации. Написал кастомный мидлвейр для обработки ошибок. Сделал энвелоуп для единого формата ответа.
Использовал логгер Serilog в связке с Seq.

Было очень много неточностей по типу: 

- какое поведение если указывается несуществующий путь? (собираются платформы по пути, а в несуществующем пути приходит пустой список)
- что если приходит в файле некорректный путь? (пропускаю и смотрю дальше пути)
- есть ли корневая локация? "/" (считаю что такого кейса не будет)
- какие расширения файлов принимает? (сделал только ".txt")
- могут ли прийти дублированные данные? (в моем решении нет, сделал HashSet)

Сделал на свое усмотрение данные неточности.

В принципе, подключив сюда тот же RabbitMq.Client и настроив контракты сообщений(через протобафы к примеру)
 можно выделить это как отдельный микросервис. Полностью работоспособное приложение.

По тестам, в принципе по моим расчетам любой запрос сюда(кроме первых очевидно, т.к. JIT компилятор это должен сам еще закэшировать)
должен отрабатывать до 10мс. На тестовые данные у меня выходило меньше 1мс.

Карлов Артур